package com.example.snarkportingtest;

/*******************************************************************************
 * Author: Seongho Park <shparkk95@kookmin.ac.kr>
 *******************************************************************************/

import android.util.Log;

import java.math.BigInteger;


import org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions;

public class BigIntegerEC {

    public final static int SECRET_BITWIDTH = 254; // number of bits in the


    public final static BigInteger FIELD_PRIME = new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617");
    public final static BigInteger COEFF_A = new BigInteger("126932"); // parameterization
    // in
    // https://eprint.iacr.org/2015/1093.pdf

    public final static BigInteger CURVE_ORDER = new BigInteger(
            "21888242871839275222246405745257275088597270486034011716802747351550446453784");

    // As in curve25519, CURVE_ORDER = SUBGROUP_ORDER * 2^3
    public final static BigInteger SUBGROUP_ORDER = new BigInteger(
            "2736030358979909402780800718157159386074658810754251464600343418943805806723");

    // The Affine point representation is used as it saves one gate per bit
    private BigIntegerAffinePoint basePoint; // The Base point both parties agree to
    private BigIntegerAffinePoint hPoint; // H is the other party's public value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication

    private BigInteger[] secretBits; // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget outputs
    private BigInteger outputPublicValue; // the x-coordinate of the key exchange


    private BigIntegerAffinePoint[] baseTable;
    private BigIntegerAffinePoint[] hTable;
    private BigInteger[] doubledivTable;
    private BigInteger[] adddivTable;
    private BigInteger subdiv;


    public BigInteger[] makesecretbits(BigInteger input){

        input = input.mod(CURVE_ORDER);
        BigInteger[] temp = zeropadBigIntegers(split(input, 1), SECRET_BITWIDTH);
        BigInteger[] output = new BigInteger[SECRET_BITWIDTH];
        System.arraycopy(temp, 0, output, 0, temp.length);
        return output;
    }

    public BigIntegerEC(BigInteger baseX, BigInteger expX) {
        this.secretBits = makesecretbits(expX);
        this.basePoint = new BigIntegerAffinePoint(baseX);

        computeYCoordinates();


        baseTable = preprocess(basePoint);
        outputPublicValue = mul(basePoint, secretBits, baseTable).x;
//        Log.d("EC out", outputPublicValue.toString());
    }
    public BigInteger[] split(BigInteger x, int chunksize) {
        int numChunks = (int)Math.ceil(x.bitLength()*1.0/chunksize);
        BigInteger[] chunks = new BigInteger[numChunks];
        BigInteger mask = new BigInteger("2").pow(chunksize).subtract(BigInteger.ONE);
        for (int i = 0; i < numChunks; i++) {
            chunks[i] = x.shiftRight(chunksize * i).and(mask);
        }
        return chunks;
    }
    public BigInteger[] zeropadBigIntegers(BigInteger[] a, int totallength){
        if(a.length == totallength){
            return a;
        }
        else if(a.length > totallength){
            System.err.println("No padding needed!");
            return a;
        } else{
            BigInteger[] output = new BigInteger[totallength];
            System.arraycopy(a, 0, output, 0, a.length);
            for(int k = a.length ; k < totallength ; k++){
                output[k] = BigInteger.ZERO;
            }

            return output;
        }
    }


    private void checkSecretBits() {

        if (secretBits.length != SECRET_BITWIDTH) {
            throw new IllegalArgumentException();
        }
    }

    private void computeYCoordinates() {
        BigInteger x = (basePoint.x);

        basePoint.y = computeYCoordinate(x);
    }

    // this is only called, when BigInteger y is provided as witness by the prover
    // (not as input to the gadget)
    private void assertValidPointOnEC(BigInteger x, BigInteger y) {
        BigInteger ySqr = y.multiply(y);
        BigInteger xSqr = x.multiply(x);
        BigInteger xCube = xSqr.multiply(x);
        assert (ySqr == xCube.add(xSqr.multiply(COEFF_A)).add(x)) : "not valid ec point!";

    }


    private BigIntegerAffinePoint[] preprocess(BigIntegerAffinePoint p) {
        BigIntegerAffinePoint[] precomputedTable = new BigIntegerAffinePoint[secretBits.length+1];
        precomputedTable[0] = p;
        this.doubledivTable = new BigInteger[secretBits.length];
        for (int j = 1; j <= secretBits.length; j += 1) {
            precomputedTable[j] = doubleBigIntegerAffinePoint(precomputedTable[j - 1], j-1);
        }
        return precomputedTable;
    }

    /**
     * Performs scalar multiplication (secretBits must comply with the conditions
     * above)
     */
    public BigIntegerAffinePoint mul(BigIntegerAffinePoint p, BigInteger[] secretBits, BigIntegerAffinePoint[] precomputedTable) {

        BigIntegerAffinePoint result = new BigIntegerAffinePoint(precomputedTable[secretBits.length]);
        adddivTable = new BigInteger[secretBits.length];
        for (int j = secretBits.length - 1; j >= 0; j--) {
            BigIntegerAffinePoint tmp = addBigIntegerAffinePoints(result, precomputedTable[j], secretBits.length -j -1);

            BigInteger isOne = secretBits[j];

            result.x = result.x.add(isOne.multiply(tmp.x.subtract(result.x))).mod(FIELD_PRIME);
            result.y = result.y.add(isOne.multiply(tmp.y.subtract(result.y))).mod(FIELD_PRIME);
        }
        result = subAffinePoints(result, precomputedTable[secretBits.length]);

        return result;
    }

    public BigIntegerAffinePoint doubleBigIntegerAffinePoint(BigIntegerAffinePoint p, int i) {
        BigInteger three = new BigInteger("3");
        BigInteger two = new BigInteger("2");
        BigInteger x_2 = p.x.multiply(p.x);
        BigInteger l1 = FieldDivision(x_2.multiply(three).add(p.x.multiply(COEFF_A).multiply(two)).add(BigInteger.ONE), p.y.multiply(two));
        doubledivTable[i] = l1;

        BigInteger l2 = l1.multiply(l1);
        BigInteger newX = l2.subtract(COEFF_A).subtract(p.x).subtract(p.x);
        BigInteger newY = p.x.multiply(three).add(COEFF_A).subtract(l2).multiply(l1).subtract(p.y);
        return new BigIntegerAffinePoint(newX.mod(FIELD_PRIME), newY.mod(FIELD_PRIME));
    }

    public BigIntegerAffinePoint addBigIntegerAffinePoints(BigIntegerAffinePoint p1, BigIntegerAffinePoint p2, int i) {
        BigInteger two = new BigInteger("2");
        BigInteger diffY = p1.y.subtract(p2.y);
        BigInteger diffX = p1.x.subtract(p2.x);
        BigInteger q = FieldDivision(diffY, diffX);
        adddivTable[i] = q;
        BigInteger q2 = q.multiply(q);
        BigInteger q3 = q2.multiply(q);
        BigInteger newX = q2.subtract(COEFF_A).subtract(p1.x).subtract(p2.x);
        BigInteger newY = p1.x.multiply(two).add(p2.x).add(COEFF_A).multiply(q).subtract(q3).subtract(p1.y);
        return new BigIntegerAffinePoint(newX.mod(FIELD_PRIME), newY.mod(FIELD_PRIME));
    }

    public BigInteger FieldDivision(BigInteger a, BigInteger b){
        BigInteger c = (a.multiply(b.modInverse(FIELD_PRIME)).mod(FIELD_PRIME));

        return c;
    }

    private BigIntegerAffinePoint subAffinePoints(BigIntegerAffinePoint p1, BigIntegerAffinePoint p2) {
        BigInteger two = new BigInteger("2");
        BigInteger diffY = p1.y.add(p2.y);
        BigInteger diffX = p1.x.subtract(p2.x);
        BigInteger q = FieldDivision(diffY, diffX);
        subdiv = q;
        BigInteger q2 = q.multiply(q);
        BigInteger q3 = q2.multiply(q);
        BigInteger newX = q2.subtract(COEFF_A).subtract(p1.x).subtract(p2.x);
        BigInteger newY = p1.x.multiply(two).add(p2.x).add(COEFF_A).multiply(q).subtract(q3).subtract(p1.y);
        return new BigIntegerAffinePoint(newX.mod(FIELD_PRIME), newY.mod(FIELD_PRIME));
    }

    public BigInteger computeYCoordinate(BigInteger x) {
        BigInteger xSqred = x.multiply(x).mod(FIELD_PRIME);
        BigInteger xCubed = xSqred.multiply(x).mod(FIELD_PRIME);
        BigInteger ySqred = xCubed.add(COEFF_A.multiply(xSqred)).add(x).mod(FIELD_PRIME);
        BigInteger y = IntegerFunctions.ressol(ySqred, FIELD_PRIME);
        return y.mod(FIELD_PRIME);
    }

    public BigInteger getYCoordinate(){
        return basePoint.y;
    }

    public BigInteger[] getAdddivTable() {
        return adddivTable;
    }

    public BigInteger[] getDoubledivTable() {
        return doubledivTable;
    }

    public BigInteger getSubdiv() {
        return subdiv;
    }

    public BigInteger getOutput(){
        return outputPublicValue.mod(FIELD_PRIME);
    }
}

