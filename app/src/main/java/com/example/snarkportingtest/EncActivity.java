package com.example.snarkportingtest;

/*******************************************************************************
 * Author: Seongho Park <shparkk95@kookmin.ac.kr>
 *******************************************************************************/

import android.util.Log;

import org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions;

import java.math.BigInteger;


/**
 * This gadget implements cryptographic key exchange using a customized elliptic
 * curve that is efficient to represent as a SNARK circuit. It follows the
 * high-level guidelines used for the design of Curve25519, while having the
 * cost model of QAP-based SNARKs in mind. Details in section 6:
 * https://eprint.iacr.org/2015/1093.pdf
 *
 * Detailed comments about the inputs and outputs of the circuit are below.
 *
 * Note: By default, this gadget validates only the secret values that are
 * provided by the prover, such as the secret key, and any intermediate
 * auxiliary witnesses that the prover uses in the circuit. In the default mode,
 * the gadget does not check the public input keys, e.g. it does not verify that
 * the base point or the other party's input have the appropriate order, as such
 * inputs could be typically public and can be checked outside the circuit if
 * needed. The Curve25519 paper as well claims that validation is not necessary
 * (although there is debate about some cases online). If any validation is
 * desired, there is a separate method called validateInputs() that do
 * validation, but is not called by default.
 *
 *
 *
 */

public class EncActivity {

    // Note: this parameterization assumes that the underlying field has
    // Config.FIELD_PRIME =
    // 21888242871839275222246405745257275088548364400416034343698204186575808495617

    public final static int SECRET_BITWIDTH = 254; // number of bits in the
    // exponent. Note that the
    // most significant bit
    // should
    // be set to 1, and the
    // three least significant
    // bits should be be zero.
    // See
    // the constructor

    public final static BigInteger FIELD_PRIME = new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617");
    public final static BigInteger COEFF_A = new BigInteger("126932"); // parameterization
    // in
    // https://eprint.iacr.org/2015/1093.pdf

    public final static BigInteger CURVE_ORDER = new BigInteger(
            "21888242871839275222246405745257275088597270486034011716802747351550446453784");

    // As in curve25519, CURVE_ORDER = SUBGROUP_ORDER * 2^3
    public final static BigInteger SUBGROUP_ORDER = new BigInteger(
            "2736030358979909402780800718157159386074658810754251464600343418943805806723");

    // The Affine point representation is used as it saves one gate per bit
    private BigIntegerAffinePoint basePoint; // The Base point both parties agree to
    private BigIntegerAffinePoint hPoint; // H is the other party's public value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication

    private BigInteger[] secretBits; // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget outputs
    private BigInteger outputPublicValue; // the x-coordinate of the key exchange
    // material to be sent to the other party
    // outputPublicValue = ((this party's
    // secret)*Base).x

    private BigInteger[] divTable;
    private BigIntegerAffinePoint[] hTable;
    private BigIntegerAffinePoint bx;
    private BigIntegerAffinePoint by;

    private BigInteger[] doubleTable1;
    private BigInteger[] addTable1;
    private BigInteger subTable1;

    private BigInteger[] doubleTable2;
    private BigInteger[] addTable2;
    private BigInteger subTable2;

    public EncActivity(BigInteger baseX, BigInteger expX, BigInteger baseY, BigInteger expY) {

//        computeYCoordinates(); // For efficiency reasons, we rely on affine
        // coordinate
//        Log.d("ec points", baseX.toString()+"\n"+expX.toString()+"\n"+baseY.toString()+"\n"+expY.toString()+"\n");

        BigIntegerEC gadget1 = new BigIntegerEC(baseX, expX);
        BigIntegerEC gadget2 = new BigIntegerEC(baseY, expY);

        bx = new BigIntegerAffinePoint(baseX, gadget1.getYCoordinate());
        by = new BigIntegerAffinePoint(baseY, gadget2.getYCoordinate());

        this.basePoint = new BigIntegerAffinePoint(gadget1.getOutput());
        this.hPoint = new BigIntegerAffinePoint(gadget2.getOutput());

        computeYCoordinates();;
//        Log.d("ec points", basePoint.x.toString()+"\n"+basePoint.y.toString()+"\n"+hPoint.x.toString()+"\n"+basePoint.y.toString()+"\n");
        this.doubleTable1 = gadget1.getDoubledivTable();
        this.addTable1 = gadget1.getAdddivTable();
        this.subTable1 = gadget1.getSubdiv();

        this.doubleTable2 = gadget2.getDoubledivTable();
        this.addTable2 = gadget2.getAdddivTable();
        this.subTable2 = gadget2.getSubdiv();


        this.divTable = new BigInteger[1];
//        Log.d("points", basePoint.x.toString()+"\n"+basePoint.y.toString()+"\n"+hPoint.x.toString()+"\n"+basePoint.y.toString()+"\n");

        BigIntegerAffinePoint out = addBigIntegerAffinePoints(basePoint, hPoint);

        outputPublicValue = out.x;
//        Log.d("add Points", outputPublicValue.toString(16));
    }

    public String[] getdoubleTable1(){
        String[] doubleTable1string = new String[doubleTable1.length];
        for(int i = 0 ; i < doubleTable1.length ; i++)
            doubleTable1string[i] = doubleTable1[i].toString(16);
        return doubleTable1string;
    }

    public String[] getaddTable1(){
        String[] addTable1string = new String[addTable1.length];
        for(int i = 0 ; i < addTable1.length ; i++)
            addTable1string[i] = addTable1[i].toString(16);
        return addTable1string;
    }

    public String[] getsubTable1(){
        String[] subTable1string = new String[1];
        subTable1string[0] = subTable1.toString(16);
        return subTable1string;
    }

    public String[] getdoubleTable2(){
        String[] doubleTable1string = new String[doubleTable2.length];
        for(int i = 0 ; i < doubleTable2.length ; i++)
            doubleTable1string[i] = doubleTable2[i].toString(16);
        return doubleTable1string;
    }

    public String[] getaddTable2(){
        String[] addTable1string = new String[addTable2.length];
        for(int i = 0 ; i < addTable2.length ; i++)
            addTable1string[i] = addTable2[i].toString(16);
        return addTable1string;
    }

    public String[] getsubTable2(){
        String[] subTable1string = new String[1];
        subTable1string[0] = subTable2.toString(16);
        return subTable1string;
    }

    public BigInteger[] getycoordinates(){
        return new BigInteger[] {bx.y, by.y};
    }

    public BigInteger[] split(BigInteger x, int chunksize) {
        int numChunks = (int)Math.ceil(x.bitLength()*1.0/chunksize);
        BigInteger[] chunks = new BigInteger[numChunks];
        BigInteger mask = new BigInteger("2").pow(chunksize).subtract(BigInteger.ONE);
        for (int i = 0; i < numChunks; i++) {
            chunks[i] = x.shiftRight(chunksize * i).and(mask);
        }
        return chunks;
    }

    public BigInteger getOutput(){

        return outputPublicValue.mod(FIELD_PRIME);
    }


    private void computeYCoordinates() {
        BigInteger x = (basePoint.x);
        basePoint.y = computeYCoordinate(x);
        BigInteger x1 = (hPoint.x);
        hPoint.y = computeYCoordinate(x1);
    }



    public BigIntegerAffinePoint addBigIntegerAffinePoints(BigIntegerAffinePoint p1, BigIntegerAffinePoint p2) {
        BigInteger two = new BigInteger("2");

        BigInteger diffY = p1.y.subtract(p2.y);
        BigInteger diffX = p1.x.subtract(p2.x);
        BigInteger q = FieldDivision(diffY, diffX);
        divTable[0] = q;
        BigInteger q2 = q.multiply(q);
        BigInteger q3 = q2.multiply(q);
        BigInteger newX = q2.subtract(COEFF_A).subtract(p1.x).subtract(p2.x);
        BigInteger newY = p1.x.multiply(two).add(p2.x).add(COEFF_A).multiply(q).subtract(q3).subtract(p1.y);
        return new BigIntegerAffinePoint(newX.mod(FIELD_PRIME), newY.mod(FIELD_PRIME));
    }

    public String[] getwitness(){
        String[] out = new String[3];
        out[0] = basePoint.y.toString(16);
        out[1] = hPoint.y.toString(16);
        out[2] = divTable[0].toString(16);
        return out;
    }

    public BigInteger FieldDivision(BigInteger a, BigInteger b){
        BigInteger c = (a.multiply(b.modInverse(FIELD_PRIME)).mod(FIELD_PRIME));

        return c;
    }


    public BigInteger computeYCoordinate(BigInteger x) {
        BigInteger xSqred = (x.multiply(x)).mod(FIELD_PRIME);
        BigInteger xCubed = (xSqred.multiply(x)).mod(FIELD_PRIME);
        BigInteger ySqred = (xCubed.add((COEFF_A.multiply(xSqred)).mod(FIELD_PRIME)).add(x)).mod(FIELD_PRIME);
        BigInteger y = IntegerFunctions.ressol(ySqred, FIELD_PRIME);
        return y;
    }





}

